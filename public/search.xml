<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo-Butterfly 文章卡片颜色修改</title>
      <link href="/2024/10/10/hexo-Butterfly-%E6%96%87%E7%AB%A0%E5%8D%A1%E7%89%87%E9%A2%9C%E8%89%B2%E4%BF%AE%E6%94%B9/"/>
      <url>/2024/10/10/hexo-Butterfly-%E6%96%87%E7%AB%A0%E5%8D%A1%E7%89%87%E9%A2%9C%E8%89%B2%E4%BF%AE%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<h1>引入自定义格式</h1><ol><li>如果主题是通过GitHub源下载的，那么你的css文件位于</li></ol><p>​<code>项目根目录\theme\butterfly\source\css\</code></p><p>​直接在这下面新建css文件即可</p><ol start="2"><li>如果是通过npm包管理器下载，即 npm install … ，那么css文件位于</li></ol><p>​<code>项目根路径\node_modules\hexo-theme-butterfly\source\css\</code></p><p>​你可以新增一个用于自定义的文件夹，命名为：_custom，这个文件夹用来存放自定义 css 格式。然后还需要在 \css 目录下的index.styl中添加如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;_custom/*.css&#x27;</span><span class="comment">//导入_custom文件夹下所有css文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要引入外链:</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;https://cdn.jsdelivr.net/gh/username/repo/css/xxx.css&#x27;</span></span><br></pre></td></tr></table></figure><p>之后就可以进行格式修改了</p><h1>修改格式</h1><p>以标题的修改文章盒子颜色为例</p><p>在刚才的_custom文件夹中新增一个css，命名随意，然后向其中添加:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 首页文章卡片 */</span></span><br><span class="line"><span class="selector-id">#recent-posts</span> &gt; <span class="selector-class">.recent-post-item</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 首页侧栏卡片 */</span></span><br><span class="line"><span class="selector-class">.card-widget</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.9</span>)<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 文章页面正文背景 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#post</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 分页页面 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#page</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 归档页面 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#archive</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 标签页面 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#tag</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 分类页面 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#category</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rgba(255, 255, 255, 0.9) 前三个表示对应的rgb值，最后一个是调节透明度。</p><p>此时也只是配置了默认状态下文章的颜色，但由于显示优先级顺序，自定义的样式会刷新主题原来的配置，当你切换黑夜模式时，会发现你的文章盒子仍然是透明的，没有随着主题变成黑色，像这样：</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev/imgs/post_Imags/202410110139853.jpg" alt="未配置黑夜模式"></p><p>因此还需要针对黑夜模式进行处理，还是在刚刚创建的那个css文件下添加以下代码（具体细节可以自己调整）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 黑夜模式下*/</span></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&#x27;dark&#x27;</span>]</span> <span class="selector-id">#recent-posts</span> &gt; <span class="selector-class">.recent-post-item</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.6</span>)<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&#x27;dark&#x27;</span>]</span> <span class="selector-class">.card-widget</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.9</span>)<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&#x27;dark&#x27;</span>]</span> <span class="selector-tag">div</span><span class="selector-id">#post</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.9</span>)<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&#x27;dark&#x27;</span>]</span> <span class="selector-tag">div</span><span class="selector-id">#page</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.9</span>)<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&#x27;dark&#x27;</span>]</span> <span class="selector-tag">div</span><span class="selector-id">#archive</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.9</span>)<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&#x27;dark&#x27;</span>]</span> <span class="selector-tag">div</span><span class="selector-id">#tag</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.9</span>)<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&#x27;dark&#x27;</span>]</span> <span class="selector-tag">div</span><span class="selector-id">#category</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.9</span>)<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，切换黑夜模式时，<strong>所有的盒子也会随之变成黑色了</strong>！</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev/imgs/post_Imags/202410110144967.jpg" alt="配置黑夜模式后"></p><p>如果还有其他格式修改需求可以看文章参考。</p><p>——————————————————————————</p><p>参考：</p><p><a href="https://juejin.cn/post/7064584521210920974#heading-1">hexo-butterfly-样式修改butterfly主题升级，记录基于hexo-butterfly的修改过程，涉及自 - 掘金 (juejin.cn)</a></p><p><a href="https://www.cnblogs.com/thinkgone/p/16348996.html">Butterfly主题美化进阶 - ThinkGone - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客教学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring笔记</title>
      <link href="/2024/10/06/Spring%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/10/06/Spring%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>:o:导学</h1><p>传统Java开发的代码耦合性过强，接口与实现紧密耦合。此外，Log等日志功能也都写在业务代码中，这使得代码非常的繁琐和重复，同时也不便于维护</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev/imgs/post_Imags/202409292032418.png" alt="Snipaste_2024-09-29_20-31-46"></p><p>为了解决这个问题，基于工厂设计模式的Ioc思想应运而生。</p><h2 id="rainbow-IoC、-DI和AOP思想">:rainbow:IoC、 DI和AOP思想</h2><p>- IOC 控制反转思想的提出<br><strong>IOC思想</strong>： Inversion of Control，翻译为“控制反转” 或“反转控制” ，强调的是原来在程序中创建Bean的权利反<br>转给第三方。<br>例如：原来在程序中手动的去 new UserServiceImpl()，手动的去new UserDaoImpl()，而根据IoC思想的指导，<br>寻求一个第三方去创建UserServiceImpl对象和UserDaoImpl对象。这样程序与具体对象就失去的直接联系。</p><blockquote><p>工厂设计模式， BeanFactory来充当第三方的角色，来产生Bean实例<br>BeanFactory怎么知道产生哪些Bean实例呢？<br>可以使用配置文件配置Bean的基本信息， BeanFactory根据配置文件来生产Bean实例</p></blockquote><p>将实例类的创建交给工厂，通过BeanFactory创建对象，具体的，我们通过代码创建一个BeanFactiry工厂对象，让他来读取配置文件并创建Bean实例</p><p>例如：</p><p>在你的业务代码中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanFactory</span>(<span class="string">&quot;Beans.xml&quot;</span>);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService)factory.getBean(<span class="string">&quot;userService&quot;</span>);<span class="comment">//getBean方法创建的是Object类</span></span><br></pre></td></tr></table></figure><p>在resources包下创建一个Bean.xml配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.service.impl.userServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--假设其中有一个方法名为setUser用于设置用户名称,你可以用下面这种方式调用它--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">ref</span> = <span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.pojo.entity.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将User在BeanFactory内部设置给userService的过程叫做注入，而UserService需要User的注入后进行工作，因此这个过程称为“<strong>依赖注入</strong>”也就是<strong>DI思想</strong></p><p><strong>AOP思想：</strong></p><p>AOP(Aspect Oriented Programming)，即面向切面编程，它也是基于代理模式，可以在代理对象中对目标对象的方法进行增强，它采用横向切面抽取方法，可以理解为在方法的前后进行一些操作，比如可以在业务代码之前生成日志，这样，你就不需要在每一段业务代码前都加入关于输出日志的代码了。</p><h2 id="rainbow-Spring容器">:rainbow:Spring容器</h2><h1>:o:基于xml的Spring应用</h1><table><thead><tr><th>Xml配置方式</th><th>功能描述</th></tr></thead><tbody><tr><td><bean id class></bean></td><td>Bean的id和全限定名配置</td></tr><tr><td><bean name></bean></td><td>通过name设置Bean的别名，通过别名也能直接获取到Bean实例</td></tr><tr><td><bean scope></bean></td><td>Bean的作用范围， BeanFactory作为容器时取值singleton和prototype</td></tr><tr><td><bean lazy-init></bean></td><td>Bean的实例化时机，是否延迟加载。 BeanFactory作为容器时无效</td></tr><tr><td><bean init-method></bean></td><td>Bean实例化后自动执行的初始化方法， method指定方法名</td></tr><tr><td><bean destroy-method></bean></td><td>Bean实例销毁前的方法， method指定方法名</td></tr><tr><td><bean autowire="byType"></bean></td><td>设置自动注入模式，常用的有按照类型byType，按照名字byName</td></tr><tr><td><bean factory-bean factory-method></bean></td><td>指定哪个工厂Bean的哪个方法完成Bean的创建</td></tr></tbody></table><h2 id="rainbow-基本使用">:rainbow:基本使用</h2><h3 id="one-Bean的实例化配置">:one:Bean的实例化配置</h3><p>Spring的实例化方式主要如下两种：</p><h4 id="构造方式实例化：">构造方式实例化：</h4><p>底层通过构造方法对Bean进行实例化</p><ul><li>有参：在xml中加一个constructor-arg标签</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.pojo.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;李华&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过调试查看实例化的值(首先确保你的User中有name和age这两个字段)</p><h4 id="工厂方式实例化：">工厂方式实例化：</h4><p>底层通过调用自定义的工厂方法对Bean进行实例化</p><ul><li>静态工厂实例化</li></ul><p>静态工厂方法实例化Bean，其实就是定义一个工厂类，提供一个静态方法用于生产Bean实例，在将该工厂类及其<br>静态方法配置给Spring即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFactoryBean</span> &#123;</span><br><span class="line"><span class="comment">//非静态工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">getUser</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="comment">//可以在此编写一些其他逻辑代码</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.factory.UserFactoryBean&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUser&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;李华&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>实例工厂实例化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFactoryBean</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser1</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(name, age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要实例化工厂Bean，通过工厂Bean的非静态方法实例化User Bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--先实例化工厂--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;MyFactoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.factory.UserFactoryBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--再实例化User--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user3&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;MyFactoryBean&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUser1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;李华&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>FactoryBean工厂实例化</li></ul><p>Spring提供了FactoryBean的接口规范，<br>FactoryBean接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">OBJECT_TYPE_ATTRIBUTE</span> <span class="operator">=</span> “factoryBeanObjectType” ;</span><br><span class="line">    </span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception; <span class="comment">//获得实例对象方法</span></span><br><span class="line">    </span><br><span class="line">    Class&lt;?&gt; getObjectType(); <span class="comment">//获得实例对象类型方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以实现这个接口，然后在xml中再配置User的Bean实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFactoryBean3</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;User&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">    <span class="keyword">return</span> User.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置FactoryBean交给Spring管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user4&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.explame.factory.MyFactoryBean3&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>通过ApplicationContext实例化的对象通常存放在：ApplicationContext-&gt;beanFactory-&gt;singletonObjects(单例池)中，但如果通过实现FactoryBean作为自定义Bean工厂配置的实例化对象并不存储在singletonObjects中，而是先保存在factiryBeanObjectCache(初沉池)中，当调用getBean方法时，才将实例化对象从初沉池中拿出放入单例池。</p><p>你可以通过Debug验证它</p></blockquote><h3 id="two-Bean的依赖注入配置">:two:Bean的依赖注入配置</h3><p>Bean的依赖注入有两种方式：</p><table><thead><tr><th>注入方式</th><th>配置方式</th><th>需求</th></tr></thead><tbody><tr><td>通过Bean的setter方法注入</td><td><property name="userDao" ref="userDao"> <br><property name="userDao" value="haohao"></property></property></td><td>需要实现对应的set方法</td></tr><tr><td>通过构造Bean的方法进行注入</td><td><constructor-arg name="name" ref="userDao"><br> <constructor-arg name="name" value="haohao"></constructor-arg></constructor-arg></td><td>在构造方法中包含这个参数</td></tr></tbody></table><blockquote><p>其中， ref 是 reference 的缩写形式，翻译为：涉及，参考的意思，用于引用其他Bean的id。 value 用于注入普通<br>属性值。</p><p>通常来说，依赖注入的数据类型有如下三种：</p><ul><li>普通数据类型，例如： String、 int、 boolean等，通过value属性指定。</li><li>引用数据类型，例如： UserDaoImpl、 DataSource等，通过ref属性指定。</li><li>集合数据类型，例如： List、 Map、 Properties等。  在下面演示</li></ul></blockquote><h4 id="集合类型数据">集合类型数据</h4><ol><li>List：为userServiceImpl加入list字段，并且提供一个公开的set方法。这里以stringList、userList作为演示</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List集合的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.springlean.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;stringList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>王五<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;user&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;user1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;user2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了方便，以下的其他集合类型的演示就默认是在userService1 Bean标签下的</p><ol start="2"><li><p>set：它与List几乎没有区别，只是将list标签换成set标签</p></li><li><p>Map：使用entry标签设置键值对</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注入值为字符串的Map集合--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;valueMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;aaa&quot;</span> <span class="attr">value</span>=<span class="string">&quot;AAA&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;bbb&quot;</span> <span class="attr">value</span>=<span class="string">&quot;BBB&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ccc&quot;</span> <span class="attr">value</span>=<span class="string">&quot;CCC&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入值为对象的Map集合--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;objMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ud&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;user&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ud2&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;user2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ud3&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;user3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>properties：使用prop标签，并在标签中指定值：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span>XXX<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;yyy&quot;</span>&gt;</span>YYY<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="three-Spring的其他配置标签">:three:Spring的其他配置标签</h3><p>Spring的默认标签用到的是Spring的默认命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该命名空间约束下的默认标签如下：</p><table><thead><tr><th>标签</th><th>作用</th></tr></thead><tbody><tr><td><beans></beans></td><td>一般作为 xml 配置根标签，其他标签都是该标签的子标签</td></tr><tr><td><bean></bean></td><td>Bean的配置标签，上面已经详解了，此处不再阐述</td></tr><tr><td><import></import></td><td>外部资源导入标签</td></tr><tr><td><alias></alias></td><td>指定Bean的别名标签，使用较少</td></tr></tbody></table><h4 id="配置环境标签">配置环境标签</h4><p>在你的xml配置文件中，可以为beans指定环境</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置测试环境下需要加载的bean实例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一些bean或其他的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Spring默认启用默认的配置环境，如果你想启用测试环境下的Bean配置，可以使用以下两种方式指定被激活的环境：</p><ul><li><p>使用命令行动态参数，虚拟机参数位置加载 -Dspring.profiles.active=test</p></li><li><p>使用代码的方式设置环境变量 System.setProperty(“spring.profiles.active”,“test”)</p></li></ul><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;System.setProperty(<span class="string">&quot;spring.profiles.active&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&gt;<span class="comment">//通过ApplicationContext获取实例化对象</span></span><br><span class="line">&gt;<span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">&gt;<span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService3&quot;</span>);</span><br></pre></td></tr></table></figure></blockquote></blockquote><h4 id="导入配置环境">导入配置环境</h4><p>即<strong>Import</strong>,通过以下方法指定导入，如果在beans2.xml中有其他的注入，也能通过ApplicationContext获取</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在beans.xml中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:application-user.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在application-user.xml中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.springlean.pojo.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;来自application-user.xml的User&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你可以在beanFactory-&gt;beanDefinitionMap的这个地方看到它的来源</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev/imgs/post_Imags/202409301546670.jpg" alt="来自"></p><h4 id="导入非Spring的第三方标签">导入非Spring的第三方标签</h4><p>由于是第三方的，不能直接在Spring中使用，需要先引入项目依赖，再在根标签的name space和shemaLocation中导入</p><p>以java RPC框架 dubbo为例</p><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--dubbo--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在bean.xml的beans根标签中添加</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://dubbo.apache.org/schema/dubbo</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在可以在beans.xml中使用dubbo的标签了</p><p><a id="section2"></a></p><p>###:four:实操（以druid数据库池为例）</p><ol><li>在pom.xml导入项目依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--druid池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.49<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过静态工厂实例化方法实例化DateSource对象</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--druid必备的driverName、url、username、password--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dateSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/sky_take_out&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过ApplicationContext获得实例对象</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="type">DruidDateSource</span> <span class="variable">dateSource</span> <span class="operator">=</span> (DruidDateSource)applicationContext.getBean(<span class="string">&quot;dateSource&quot;</span>);</span><br></pre></td></tr></table></figure><p>于是获得了一个DruidDataSource实例对象</p><h2 id="rainbow-Bean-实例化的流程-原理">:rainbow:Bean 实例化的流程(原理)</h2><h3 id="one-读取配置文件并封装需要实例化的对象">:one:读取配置文件并封装需要实例化的对象</h3><p>Spring容器在进行初始化时，会将xml配置的 bean 的信息封装成一个 <strong>BeanDefinition</strong> 对象，所有的BeanDefinition存储到一个名为 <strong>beanDefinitionMap</strong> 的Map集合中去， Spring框架在对该Map进行遍历，使用反射创建Bean实例对象，创建好的Bean对象存储在一个名为 <strong>singletonObjects</strong> 的Map集合中，当调用getBean方法时则最终从该Map集合中取出Bean实例对象返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//singletonObjects的底层 DefaultListableBeanFactory和其中维护的beanDefinitionMap</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultListableBeanFactory</span> extends ... implements ... &#123;</span><br><span class="line"><span class="comment">//存储&lt;bean&gt;标签对应的BeanDefinition对象</span></span><br><span class="line"><span class="comment">//key:是Bean的beanName， value:是Bean定义对象BeanDefinition</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring框架会取出beanDefinitionMap中的每个BeanDefinition信息，<strong>反射构造方法</strong>或<strong>调用指定的工厂方法</strong>生成Bean实例对象，所以只要将BeanDefinition注册到beanDefinitionMap这个Map中， Spring就会进行对应的Bean的实例化操作</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev/imgs/post_Imags/202409302108737.jpg" alt="Spring实例化流程"></p><h3 id="two-通过反射创建对象并存放到单例池中">:two:通过反射创建对象并存放到单例池中</h3><p>Bean实例及单例池<strong>singletonObjects</strong>， <strong>beanDefinitionMap</strong>中的<strong>BeanDefinition</strong>会被转化成对应的Bean实例对象，存储到单例池singletonObjects中去，在<strong>DefaultListableBeanFactory</strong>的上四级父类DefaultSingletonBeanRegistry中，维护着<strong>singletonObjects</strong>单例池，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultListableBeanFactory的上四级父类DefaultSingletonBeanRegistry和其中维护的singletonObjects</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> extends ... implements ... &#123;</span><br><span class="line"><span class="comment">//存储Bean实例的单例池</span></span><br><span class="line"><span class="comment">////key:是Bean的beanName， value:是Bean的实例对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">256</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><blockquote><p>:coffee:总结：Bean 实例化的基本流程</p><ul><li>加载xml配置文件，解析获取配置中的每个<bean>的信息，封装成一个个的BeanDefinition对象;</bean></li><li>将BeanDefinition存储在beanDefinitionMap ==&gt; Map&lt;String,BeanDefinition&gt;中;</li><li>ApplicationContext底层遍历beanDefinitionMap，创建Bean实例对象;</li><li>创建好的Bean实例对象，存储到singletonObjects ==&gt; Map&lt;String,Object&gt;中;</li><li>当执行applicationContext.getBean(beanName)时，从singletonObjects去匹配Bean实例返回。</li></ul></blockquote><h2 id="rainbow-后处理器">:rainbow:后处理器</h2><table><thead><tr><th>后处理器</th><th>作用</th></tr></thead><tbody><tr><td>BeanProcessor</td><td>在Bean实例化之后，填充到单例池singletonObjects之前执行</td></tr><tr><td>BeanFactoryPostProcessor</td><td>在BeanDefinitionMap填充完成后，还没开始创建实例之前执行</td></tr><tr><td>BeanDefinitionRegistryPostProcessor</td><td>用作向BeanDefinitionMap中注册BeanDefinition。它是BeanFactoryPostProcessor的子类,调用时机也和BeanFactoryPostProcessor相同</td></tr></tbody></table><p>在使用后处理器时，需要实现对应的处理器接口，然后<strong>将处理器的实现配置到xml配置文件中作为Bean</strong>，这样Spring会自动的在相应的时间调用后处理器的方法。</p><h3 id="one-Bean工厂后处理器">:one:Bean工厂后处理器</h3><p>:tea:：以通过BeanDefinitionRegistryPostProcessor注册为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(<span class="string">&quot;com.example.pojo.entity.User&quot;</span>);</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;user4&quot;</span>, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过xml配置存储在BeanDefinitionMap中的BeanDefinition是GenericBeanDefinition，但通过后处理器注册BeanDefinition推荐使用RootBeanDefinition</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev/imgs/post_Imags/202409302238650.jpg" alt="默认的BeanDefinition"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--不要忘了将后处理器配置到Spring容器中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.example.processor.RegisterProcessor&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>此时，我们可以为之前的Spring实例化流程的流程图进行一些补充</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev/imgs/post_Imags/202409302248465.jpg" alt="更多细节"></p><h3 id="two-通过注解实例化">:two:通过注解实例化</h3><p>学习完bean后处理器后，我们知道了如何在Spring实例化的不同时间段加入一个新的类以将他实例化，这非常有用处。</p><p>我们很容易发现，通过配置xml文件来实例化对象<strong>非常麻烦</strong>，但如果将后处理器结合上<code>ResourcePatternResolver</code>（一个用来扫描包下的所有类的Spring提供的工具类和它的实现：<code>PathMatchingResourcePatternResolver</code>）就能够实现<strong>只需要为需要实例化的类加上一个注解即可实现类的实例化。</strong></p><blockquote><p><a href="https://springdoc.cn/spring/core.html#resources-resourcepatternresolver">什么是ResourcePatternResolver</a></p></blockquote><ol><li>首先自定义一个注解，随便叫什么名字，我这里叫做<code>MyComponent</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span><span class="comment">//指定注解作用的类型，包括 Type、Field、Method、Package等，这里指定为Type，表示作用于类</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//注解生效的时限（注解的生命周期），这里配置为运行时仍生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyCommponent&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;<span class="comment">//这将用来在给类添加注解时指定类名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>为任何一个你想要实例化的类添加@MyComponent注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyComponent(&quot;oneBean&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">oneBean</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>接下来，编写一段代码来<strong>读取指定包（Package）下的所有添加了注解的类</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springlean.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.anno.MyComponent;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.ResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.classreading.CachingMetadataReaderFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.classreading.MetadataReader;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.classreading.MetadataReaderFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.ClassUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseClassScanUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置资源规则</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RESOURCE_PATTERN</span> <span class="operator">=</span> <span class="string">&quot;/**/*.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Class&gt; <span class="title function_">scanMyComponentAnnotation</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建容器存储使用了指定注解的Bean字节码对象</span></span><br><span class="line">        Map&lt;String, Class&gt; annotationClassMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Class&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//spring工具类，可以获取指定路径下的全部类</span></span><br><span class="line">        <span class="type">ResourcePatternResolver</span> <span class="variable">resourcePatternResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//拼接模式匹配字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + <span class="comment">//即&quot;classpath*:&quot;</span></span><br><span class="line">                    ClassUtils.convertClassNameToResourcePath(basePackage) + </span><br><span class="line">                RESOURCE_PATTERN;<span class="comment">//即&quot;/**/*.class&quot;</span></span><br><span class="line">            <span class="comment">//读取所有的类</span></span><br><span class="line">            Resource[] resources = resourcePatternResolver.getResources(pattern);</span><br><span class="line">            <span class="comment">//MetadataReader 的工厂类</span></span><br><span class="line">            <span class="type">MetadataReaderFactory</span> <span class="variable">refractory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>(resourcePatternResolver);</span><br><span class="line">            <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                <span class="comment">//MetadataReader：用于读取类信息</span></span><br><span class="line">                <span class="type">MetadataReader</span> <span class="variable">reader</span> <span class="operator">=</span> refractory.getMetadataReader(resource);</span><br><span class="line">                <span class="comment">//扫描到的class</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">classname</span> <span class="operator">=</span> reader.getClassMetadata().getClassName();</span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(classname);</span><br><span class="line">                <span class="comment">//判断是否属于指定的注解类型，按照个人的注解名字更改</span></span><br><span class="line">                <span class="keyword">if</span>(clazz.isAnnotationPresent(MyComponent.class))&#123;</span><br><span class="line">                    <span class="comment">//获得注解对象</span></span><br><span class="line">                    <span class="type">MyComponent</span> <span class="variable">annotation</span> <span class="operator">=</span> clazz.getAnnotation(MyComponent.class);</span><br><span class="line">                    <span class="comment">//获得属value属性值</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> annotation.value();</span><br><span class="line">                    <span class="comment">//判断是否为&quot;&quot;</span></span><br><span class="line">                    <span class="keyword">if</span>(beanName!=<span class="literal">null</span>&amp;&amp;!beanName.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                        <span class="comment">//存储到Map中去</span></span><br><span class="line">                        annotationClassMap.put(beanName,clazz);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果没有为&quot;&quot;,那就把当前类的类名作为beanName</span></span><br><span class="line">                    annotationClassMap.put(clazz.getSimpleName(),clazz);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> annotationClassMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scanMyComponentAnnotation的参数表示源代码包，按照你的包结构传递对应的参数就可以获取对应包下所有加入了MyComponent注解的类。</p><ol start="4"><li>在这之后就可以借助<strong>bean工厂后处理器</strong>将这些添加了注解的类加入到BeanDefinitionMap中了</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">package</span> com.example.springlean.processor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springlean.utils.BaseClassScanUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.RootBeanDefinition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">//获取所有加入了@MyComponent注解的类 </span></span><br><span class="line">        Map&lt;String, Class&gt; classMap = BaseClassScanUtils.scanMyComponentAnnotation(<span class="string">&quot;com.example&quot;</span>);<span class="comment">//这是我的软件包的目录</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将类注册到BeanDefinitionMap中</span></span><br><span class="line">        classMap.forEach((beanName, clazz) -&gt;&#123;</span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(clazz);</span><br><span class="line">            beanDefinition.setBeanClassName(clazz.getName());<span class="comment">//指定全限定名，相当于配置xml标签时的class=&quot;&quot;</span></span><br><span class="line">            registry.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要在开始实例化之前将BeanDefinition注册，因此需要使用<strong>BeanFactoryPostProcessor</strong>或<strong>BeanDefinitionRegistryPostProcessor</strong></p><blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">&lt;!--不要忘了将后处理器配置到Spring容器中--&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.example.processor.RegisterProcessor&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></blockquote><p>之后就可以在spring容器中获取到oneBean了！🎉🎉🎉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">oneBean</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;oneBean&quot;</span>);</span><br><span class="line">        System.out.println(oneBean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="three-bean后处理器">:three:bean后处理器</h3><p>beanPostProcessor</p><blockquote><p>前面已经讲过，Bean被实例化后，到最终缓存到名为singletonObjects单例池之前，中间会经过Bean的初始化过程，例如：属性的填充、初始方法init的执行等，其中有一个对外进行扩展的点BeanPostProcessor，我们称为Bean后处理。跟上面的Bean工厂后处理器相似，它也是一个接口，实现了该接口并被容器管理的BeanPostProcessor，会在流程节点上被Spring自动调用。</p></blockquote><p>BeanPostProcessor的接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="comment">//在属性注入完毕，init初始化方法执行之前被回调</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> </span><br><span class="line">    BeansException &#123;</span><br><span class="line">    <span class="keyword">return</span> bean;<span class="comment">//返回bean对象放入单例池中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="comment">//在初始化方法执行之后，被添加到单例池singletonObjects之前被回调</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> </span><br><span class="line">    BeansException &#123;</span><br><span class="line">   <span class="keyword">return</span> bean;<span class="comment">//返回bean对象放入单例池中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过Bean后处理器+动态代理增强方法实现日志打印</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springlean.processor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeLogBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span>&#123;</span><br><span class="line">        <span class="comment">//对bean进行动态代理，此时单例池中存放的不再是原来的Bean实例，而是方法被增强的代理实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proxyBean</span> <span class="operator">=</span> Proxy.newProxyInstance(</span><br><span class="line">                bean.getClass().getClassLoader(),</span><br><span class="line">                bean.getClass().getInterfaces(),</span><br><span class="line">                (proxy, method, args) -&gt; &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;开始时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">invoked</span> <span class="operator">=</span> method.invoke(bean, args);</span><br><span class="line">                        System.out.println(<span class="string">&quot;结束时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">                        <span class="keyword">return</span> invoked;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> proxyBean;<span class="comment">//将代理对象返回放入单例池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bean实例化的初始阶段的全过程：</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev/imgs/post_Imags/202410022019724.jpg" alt="Snipaste_2024-10-02_20-19-05"></p><h2 id="rainbow-​xml配置第三方框架">:rainbow: ​xml配置第三方框架</h2><h3 id="one-mybatisMapper">:one: mybatisMapper</h3><p>之前有通过Spring来xml配置来获取sqlSession的实例：​<a href="#section2">跳转</a>。现在演示另一种：sqlSessionFactoryBean+MapperScannerConfigurer的获取Mapper来操作数据库。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在 ApplicationContext.xml 中--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--基本配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置SqlSessionFactoryBean，将SqlSessionFactory存储到spring容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--MapperScannerConfigurer,扫描指定的包，产生Mapper对象存储到Spring容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在mapper包下创建了一个UserMapper：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">selectById</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为所需的Mapper配置一个xml文件，同时命名空间中指向这个Mapper。由于前面配置了扫描包，他会自己读取到其中的配置文件，并将SQL操作代理给Mapper的代理类，然后放到Spring容器中。</p><p>在resource包的mapper下新建一个UserMapper.xml配置文件,我这里随意写一个select语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你可以通过Spring容器直接拿到UserMapper对象(实际上是一个代理对象)</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev/imgs/post_Imags/202410042301785.jpg" alt="userMapper代理"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> applicationContext.getBean(UserMapper.class);</span><br></pre></td></tr></table></figure><p>这样就可以使用UserMapper的select方法从user表中读取数据了。</p><p>之后需要其他的Mapper，不需要做基本配置，在mapper包下新建一个对应的Mapper。然后在resources包下的mapper中也新建一个对应的.xml文件并将SQL操作写在配置文件中。</p><blockquote><p>实际上开发中都是使用SpringBoot+MyBatisPlus的配置方法。但是这里是学习Spring，所以以此为例子而已。</p><blockquote><p>SpringBoot+MyBatisPlus</p><p>首先确保导入了SpringBoot的MyBatisPlus依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在ApplicationContext中配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="comment">#mapper配置文件</span></span><br><span class="line"><span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line"><span class="attr">type-aliases-package:</span> <span class="string">com.example.entity</span></span><br></pre></td></tr></table></figure><blockquote><p>mapper-locations 指定了mapper配置文件的路径</p><p>type-aliases-package 让你可以在这个包下不用使用全限定名</p></blockquote><p>此后就只需要在对应的 mapper.xml 的命名空间中指向对应的类即可</p></blockquote></blockquote><h1>:o:Bean的生命周期</h1><p>————————————</p><blockquote><p>本节参阅：</p><p><strong>[Spring Bean 的生命周期 - spring 中文网 (<a href="http://springdoc.cn">springdoc.cn</a>)](<a href="https://springdoc.cn/the-life-cycle-of-a-spring-bean/#:~:text=%E6%9C%AC%E6%96%87%E4%BB%8B%E7%BB%8D%E4%BA%86">https://springdoc.cn/the-life-cycle-of-a-spring-bean/#:~:text=本文介绍了</a> Spri)</strong></p><p><a href="https://www.bilibili.com/video/BV1rt4y1u7q5?p=48&amp;vd_source=3b2548ca76d1728cf98fff60e44d3e0a">47-SpringBean的生命周期_哔哩哔哩_ bilibili</a></p><p><a href="https://cloud.tencent.com/developer/article/2184201">Bean的生命周期 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p></blockquote><p>Spring Bean的生命周期是从 Bean 实例化之后，即通过反射创建出对象之后，到Bean成为一个完整对象，存储到单例池中，到Bean最后被销毁，这个过程被称为Spring Bean的生命周期。 Spring Bean的生命周期大体上分为四个阶段：实例化阶段、初始化阶段、完成阶段、销毁阶段。</p><ul><li>Bean的实例化阶段： Spring框架会取出BeanDefinition的信息进行判断当前Bean的范围是否是singleton的，是否不是延迟加载的，是否不是FactoryBean等，最终通过反射进行实例化singleton的Bean；</li><li>Bean的初始化阶段： Bean创建之后还仅仅是个&quot;半成品&quot;，还需要对Bean实例的属性进行填充、执行一些Aware接口方法、执行BeanPostProcessor方法、执行InitializingBean接口的初始化方法、执行自定义初始化init方法等。</li></ul><blockquote><p>该阶段是Spring最具技术含量和复杂度的阶段， Aop增强功能，Spring的注解功能等、Bean的循环引用问题都是在这个阶段体现的；</p></blockquote><ul><li>Bean的完成阶段：经过初始化阶段， Bean就成为了一个完整的Spring Bean，被存储到单例池singletonObjects中去了，即完成了Spring Bean的整个生命周期。</li><li>Bean销毁阶段</li></ul><p>下图是Spring在创建一个Bean时的方法调用流程图，可以帮助理解Bean的生命周期</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev/imgs/post_Imags/202410041639236.png" alt="SpringBean生命周期"></p><p><strong>更多细节：</strong></p><p><img src= "/img/friend_404.gif" data-lazy-src="https://s2.loli.net/2024/10/02/iuOqJWrm2h9tcMl.png" alt="Spring构建bean时的方法调用"></p><h2 id="rainbow-Aware接口">:rainbow: Aware接口</h2><p>前面两个关于Spring生命周期的图中都涉及到了一些Aware接口，Aware接口提供了一个让程序员获得框架的一些对象的机会。Aware接口在不同的阶段被调用，并且将对应的对象通过参数注入给你，你所需要做的，就是实现对应的接口，然后在重新方法中实现编写预期逻辑。</p><p>以下是一些常见的Aware接口：</p><table><thead><tr><th>Aware接口</th><th>回调方法</th><th>作用</th></tr></thead><tbody><tr><td>ServletContextAware</td><td>setServletContext(ServletContext context)</td><td>Spring框架回调方法注入ServletContext对象， web环境下才生效</td></tr><tr><td>BeanFactoryAware</td><td>setBeanFactory(BeanFactory factory)</td><td>Spring框架回调方法注入beanFactory对象</td></tr><tr><td>BeanNameAware</td><td>setBeanName(String beanName)</td><td>Spring框架回调方法注入当前Bean在容器中 的beanName</td></tr><tr><td>ApplicationContextAware</td><td>setApplicationContext(ApplicationContext applicationContext)</td><td>Spring框架回调方法注入applicationContext 对象</td></tr></tbody></table><p>现在，终于知道了Spring构建Bean的完整流程：</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev/imgs/post_Imags/202410041650431.jpg" alt="Spring构建Bean完整流程"></p><h1>:o: 基于注解的Spring应用</h1><p>通过注解能够实现和xml配置相同的功能，而且更便捷更容易</p><h2 id="rainbow-基本注解">:rainbow: 基本注解</h2><h3 id="one-和实例化相关的">:one: 和实例化相关的</h3><p>这实际上相当于在xml中配置一个bean标签</p><p>@Component 用于注册到Spring容器，它的其他配置信息也可以通过注解来实现</p><table><thead><tr><th>xml配置</th><th>注解</th><th>描述</th></tr></thead><tbody><tr><td><bean scope></bean></td><td>@Scope</td><td>在类上或使用了@Bean标注的方法上，标注Bean的作用范围，取值为 singleton或prototype</td></tr><tr><td><bean lazy-init></bean></td><td>@Lazy</td><td>在类上或使用了@Bean标注的方法上，标注Bean是否延迟加载，取值为 true和false</td></tr><tr><td><bean init-method></bean></td><td>@PostConstruct</td><td>在方法上使用，标注Bean的实例化后执行的方法</td></tr><tr><td><bean destroy-method></bean></td><td>@PreDestroy</td><td>在方法上使用，标注Bean的销毁前执行方法</td></tr></tbody></table><p>此外，还有几个注解和它作用相同，只是用于不同的应用常见。</p><table><thead><tr><th>@Component衍生注解</th><th>描述</th></tr></thead><tbody><tr><td>@Repository</td><td>在Dao层类上使用</td></tr><tr><td>@Service</td><td>在Service层类上使用</td></tr><tr><td>@Controller</td><td>在Web层类上使用</td></tr></tbody></table><h3 id="two-依赖注入">:two: 依赖注入</h3><p>注入属性值的注解有：</p><table><thead><tr><th>属性注入注解</th><th>描述</th></tr></thead><tbody><tr><td>@Value</td><td>使用在字段或方法上，用于注入普通数据</td></tr><tr><td>@Autowired</td><td>使用在字段或方法上，用于根据类型（byType）注入引用数据</td></tr><tr><td>@Qualifier</td><td>使用在字段或方法上，结合@Autowired， 根据名称注入</td></tr><tr><td>@Resource</td><td>使用在字段或方法上，根据类型或名称进行注入</td></tr></tbody></table><p><strong>这些注解可以用在方法的参数上</strong>，为参数自动注入对象或值</p><blockquote><p>注：Value还可以通过$符指向在properties中配置的键值对，像前面xml中一样。前提是在配置了</p><p>&lt;context:property-placeholder location=“classpath:jdbc.properties”/&gt;  标签</p><p>这类标签也可以通过注解进行配置：<a href="#section3">注解配置非默认标签</a>, 现在可以先在xml中配置验一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同时，在jdbc.properties中</span></span><br><span class="line">jdbc.username=root</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="meta">@Resource(name = &quot;userDao2&quot;)</span><span class="comment">//会自动将配置了@Component(&quot;userDao2&quot;)的类注入到方法的参数中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span>&#123;</span><br><span class="line">System.out.println(userDao);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="three-非自定义Bean的注解">:three: 非自定义Bean的注解</h3><p>@Bean注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以MyBatis的dataSource举例</span></span><br><span class="line"><span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>);</span><br><span class="line">dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">dataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>忘记的可以点击：<a href="#section2">跳转</a></p><p><strong>之前自动注入的注解可以用在参数上</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(<span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span> String Driver,</span></span><br><span class="line"><span class="params">                            <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span> String url,</span></span><br><span class="line"><span class="params">                            <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span> String username,</span></span><br><span class="line"><span class="params">                            <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span> String password,)</span>&#123;</span><br><span class="line"><span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">dataSource.setDriverClassName(Driver);</span><br><span class="line">dataSource.setUrl(url);</span><br><span class="line">dataSource.setUsername(username);</span><br><span class="line">dataSource.setPassword(password);</span><br><span class="line"><span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法上配置了@Bean时，如果方法中的参数也在Spring容器中，这个参数会被自动注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(User User)</span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="four-Configuration注解">:four: @Configuration注解</h3><p><strong>@Configuration</strong> 注解标识的类为配置类，替代原有xml配置文件，该注解第一个作用是标识该类是一个配置类，第<br>二个作用是具备@Component作用</p><p><strong>@ComponentScan</strong> 组件扫描配置，替代原有xml文件中的&lt;context:component-scan base-package=“”/&gt;</p><p><a id="section3"></a></p><p><strong>@PropertySource</strong> 注解用于加载外部properties资源配置，替代原有xml中的 &lt;context:propertyplaceholder location=“” /&gt; 配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.example.service&quot;,&quot;com.example.pojo&quot;&#125;)</span></span><br><span class="line"><span class="meta">@PropertySource(&#123;&quot;classpath:jdbc.properties&quot;&#125;)</span><span class="comment">//它的value是一个String数组，所以用&#123;&#125;包含，表示数组中的元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>此时获取Spring容器就不再通过ClassPathXmlApplicationContext获取，而是AnnotationConfigApplicationContext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">AnnotationConfigApplicationContext</span>(ApplicationContextConfig.class);</span><br></pre></td></tr></table></figure><p>你可以通过它获取对应包下加入了@Component相关注解的实例对象</p><h3 id="five-更多…">:five: 更多…</h3><p>还有：</p><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td>@profile</td><td>变量的环境</td></tr><tr><td>@import</td><td>导入其他配置</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>注解太多了，使用也不难，和xml方式的不同就是读取的是配置的注解而不是配置文件，其他的更底层的逻辑都是类似的。</p><blockquote><p>不同注解的读取器也是通过Bean工厂后处理器等注册到Spring容器当中的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如Autowired注解，通过实现Bean后处理器，将这个注解加入到Spring容器当中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">SmartInstantiationAwareBeanPostProcessor</span>, MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环依赖和三级缓存</title>
      <link href="/2024/10/03/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%92%8C%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
      <url>/2024/10/03/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%92%8C%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p><img src= "/img/friend_404.gif" data-lazy-src="/2024/10/03/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%92%8C%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/preview.gif" alt></p><blockquote><p>本文参考：</p><p><a href="https://springdoc.cn/revisiting-spring-s-circular-dependencies/"><strong>再谈谈 Spring 中的循环依赖 - spring 中文网 (springdoc.cn</strong>)</a></p><p><a href="https://cloud.tencent.com/developer/article/1497692">一文告诉你Spring是如何利用&quot;三级缓存&quot;巧妙解决Bean的循环依赖问题的 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p></blockquote><h1>:o: 什么是循环依赖</h1><p>循环依赖的场景来自于你以前开发时可能遇到过的情况：有这样两个类，A和B，A中存在一个B的引用，同时B中也存在一个A的引用，如果不适用Spring的依赖注入，在正常的开发中或许不会有太大的问题，但在一个自动注入的场景，很有可能发生当实例化A时，需要实例化B，而跑去实例化B时，又需要实例化一个A，陷入一个循环，很快就内存溢出了。</p><blockquote><p>我在学习JavaSE的时候写一个小游戏就遇到过类似的场景，这是由我的类的设计存在问题。</p><p>我的游戏具有一个登录窗口，我使用一个LoginFrame；然后是一个GameFrame窗口，为了实现在这两个窗口之间能够实现转换(登陆成功后呼出GameFrame、退出登陆时呼出LoginFrame)，我很愚蠢的在LoginFrame中加上GameFrame字段、同时在GameFrame中加入LoginFrame字段。每次呼出另一个窗口时都新建一个窗口，并将当前窗口设为不可见。</p><p>当然我现在意识到我只需要将这两个Frame实例化后交给一个类管理，并通过这个中间类设置双方的可见性即可</p></blockquote><p>在谈论什么是循环依赖之前，先了解一下什么依赖注入的概念。</p><h2 id="pill-依赖注入">:pill: 依赖注入</h2><p>在Spring中，可以在xml文件中配置一个bean标签进行实例化，默认会将这个类的实例对象放到**单例池 ** singletonObjects中。你还可以为这个类的每一个字段设置指定的值，只要你为这个字段提供一个set方法。</p><p>假设有一个人叫张三，他是一名工人，他的老板叫老王，现在需要借助依赖注入实例化张三和老王</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--一个Boss类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Boss&quot;</span><span class="attr">class</span>=<span class="string">&quot;com.example.entity.Boss&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;老王&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--一个Employee类，它有一个Boss属性，表示它的Boss是谁--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Employee&quot;</span><span class="attr">class</span>=<span class="string">&quot;com.example.entity.Employee&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Boss&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;Boss&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ref 是 reference 的缩写形式，表示引用其他Bean的id。</p><p>在创建(<strong>new</strong>)Employee后，由于需要对它进行依赖注入，Spring会去寻找单例池(singletonObjects)中是否存在Boss这个实例，如果不存在，先创建这个实例，放入单例池中，回溯到依赖注入的地方，再为Employee注入Boss对象，然后再将Employee放入单例池中。</p><h2 id="pill-​循环依赖">:pill: ​循环依赖</h2><p>前面提到，创建Employee后，要对它的Boss字段进行注入。会先到单例池中找是否有Boss对象，没有的话，会创建Boss对象，思考一下，如果Boss中同样存在Employee的实例，且同样需要通过Spring注入。坏了，创建Employee，需要先创建Boss，但创建Boss，又需要给他注入一个Employee，这下陷入死循环了。</p><p>这样的场景就叫做循环依赖。</p><h1>:o: 如何解决</h1><p>##:pill: Java地址传递特性</p><p>既然Employee和Boss已经采取单例模式了，那么是否可以在创建Employee后，还没有注入Boss之前，将Employee记录下来，接下来继续之前所讲的，注入Boss需要新建Boss，等到新建 Boss 注入Employee时，将之前记录的Employee直接给Boss，这样就能够跳出循环而不用新建一个Employee了。</p><p>而且由于Java引用类型的地址传递特性，Employee和Boss之间的互相指向的是对方的地址，这意味着当Boss完成它的所有内容的自动注入时，Employee中的Boss就是这个完全体的Boss。</p><h1>:o: 三级缓存</h1><p>在 DefaultListableBeanFactory  向上四级父类DefaultSingletonBeanRegistry中有三个容器：</p><p>Spring就是使用这三个Map解决缓存依赖问题的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> ... &#123;</span><br><span class="line"><span class="comment">//1、最终存储单例Bean成品的容器，即实例化和初始化都完成的Bean，称之为&quot;一级缓存&quot;</span></span><br><span class="line">Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">256</span>);</span><br><span class="line"><span class="comment">//2、早期Bean单例池，缓存半成品对象，且当前对象已经被其他对象引用了，称之为&quot;二级缓存&quot;</span></span><br><span class="line">Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">16</span>);</span><br><span class="line"><span class="comment">//3、单例Bean的工厂池，缓存半成品对象，对象未被引用，使用时在通过工厂创建Bean，称之为&quot;三级缓存&quot;</span></span><br><span class="line">Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>单例池singletonObjects用来存放完全构建好的实例对象</p></li><li><p>earlySingletonObjects 当这个对象还没有完全创建，而它已经被其他对象引用时，就会先放在这个二级缓存中</p><ul><li>举个例子：Boss老王可能不止张三一个雇工，在新建第二个雇工时，Boss老王可能还没完成构建好，但已经被Employee张三引用了，这时老王就在第earlySingletonObjects池中</li></ul></li><li><p>singletonFactories 每一个新建对象都会被先放到这个池子中，如果完全构建好，才从这个池子中挪到一级缓存；如果被其他对象引用了，就放到二级缓存中去</p></li></ul><blockquote><p>补充：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Names of beans that are currently in creation. */</span></span><br><span class="line"><span class="comment">// bean创建过程中都会存放在这个Map中</span></span><br><span class="line"><span class="comment">// 它在Bean开始创建时放值，创建完成时将其移出</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Names of beans that have already been created at least once. */</span></span><br><span class="line"><span class="comment">// 当这个Bean被创建完成后，会标记为这个 注意：这里是set集合 不会重复</span></span><br><span class="line"><span class="comment">// 至少被创建了一次的  都会放进这里</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>));</span><br></pre></td></tr></table></figure></blockquote><h2 id="pill-getSingleton方法">:pill: getSingleton方法</h2><p>三级缓存 <strong>singletonFactories</strong> 就是用来存放未完全实例化的类的。</p><p>在当前类(<strong>DefaultSingletonBeanRegistry</strong>)中存在<strong>getSingleton</strong>()方法用来获取池子中的对象。<strong>这个方法会在创建实例时需要为他进行依赖注入时调用，用来找那个需要注入的字段。<strong>它会先在第一季缓存singletonObjects中找需要注入的的bean，然后是第二级缓存earlySingletonObjects，最后是第三级缓存singletonFactories。如果发现</strong>存在于第三级缓存</strong>中，程序将这个bean<strong>从第三级缓存中取出放入第二级缓存</strong>。当然，在这段过程中，他会判断这个Bean是否正在新建，如果没有，这个方法不会往下执行，直接返回去新建这个Bean。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line"><span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);<span class="comment">//在第一季缓存中找</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);<span class="comment">//在第二级缓存中找</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();<span class="comment">//在第三级缓存中找</span></span><br><span class="line"><span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pill-兼顾实例化的getSingleton方法">:pill: 兼顾实例化的getSingleton方法</h2><p>同时你会注意到，在<strong>DefaultSingletonBeanRegistry</strong>类中还有一个getSingleton()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法兼顾新建Bean的功能，在Spring容器创建后，加载配置文件(.xml文件)，就会调用到这个方法来新建对象。</p><p><strong>知道了Spring存在三级缓存读取机制，接下来再来讲Spring具体是如何使用三级缓存机制解决问题的。</strong></p><h1>:o: Bean的生命周期:</h1><p>如果要搞清楚Spring解决循环依赖的全过程和三级缓存的实现源码，就必须要先了解 Spring 创建一个 Bean 的全过程。下图是发生循环依赖时，从Spring容器加载配置文件起，程序的方法调用流程图：</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev/imgs/post_Imags/202410031448241.jpg" alt="三级缓存源码剖析流程_page-0001"></p><p>上图假设有两个Bean，A和B，它们之间形成循环依赖。</p><ol><li><p>在<strong>初始化A的过程中需要注入B，因此进行了B的实例化和初始化</strong>（图中1到3部分），B的实例化过程中又需要注入A（图中4到5部分），此时从三级缓存中获取到A，并把A从三级缓存移到二级缓存，也就是图中第六部分标红的方法。</p></li><li><p>然后方法调用结束，开始回溯，继续B的其他初始化阶段。（图中的5到4部分）</p></li><li><p>B完全构建完成，将B从三级缓存移到一级缓存（单例池）中。然后回溯到A的初始化部分，（图中的3部分）</p></li><li><p>A完全构建完毕，将A放到一级缓存，并把三级和二级缓存中的A删除（如果有的话）</p></li></ol><blockquote><p>需要注意的是，在Bean刚被实例化（也就是new出来，在内存空间具有地址后），Bean就会被放到三级缓存中。具体可以参看doGetBean方法</p></blockquote><p>可以debug查看方法调用情况：</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev/imgs/post_Imags/202410031532295.jpg" alt="Spring容器加载Bean的栈轨迹"></p><h2 id="pill-​跟着方法调用的脚步">:pill: ​跟着方法调用的脚步</h2><p>前面提到，在程序刚开始为Spring容器中加载Bean时，会调用兼顾实例化的getSingleton方法，这个方法中就会对未找到的Bean构建实例化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//兼顾实例化的getSingleton方法的调用 ———— 在AbstractBeanFactory 的doGetBean方法中</span></span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//getSingleton方法的定义</span></span><br><span class="line"><span class="comment">//其中的ObjectFactory是一个函数式接口，它只有一个getObject()方法。</span></span><br><span class="line"><span class="comment">//前面调用getSingleton的lambda表达式就是在重写这个方法</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">...</span><br><span class="line">    singletonObject = singletonFactory.getObject();<span class="comment">//在调用getObject()方法时相当于在调用createBean(beanName, mbd, args)</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//createBean方法中又调用了一个doCreateBean方法</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line"><span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了程序的健壮性，有时候不得不像这样层次嵌套，get里有个doGet，create里有个doCreate，之间做的很多工作都是健壮性和拓展性，然后将具体的功能抽象成不同的方法。</p><h2 id="pill-doCreatBean方法">:pill: doCreatBean方法</h2><p>在AbstractAutowireCapableBeanFactory这个类中有doCreateBean方法，也就是前面方法调用分析最后调用的那个doCreateBean方法。这个方法大致交代了Bean的一生（<strong>生命周期</strong>）</p><p>doCreateBean方法解析：</p><p>doCreateBean方法主要做了四件事：</p><ul><li>实例化Bean</li><li>Bean字段填充</li><li>初始化Bean</li><li>添加销毁方法</li></ul><p>大致可以分为几大模块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">beanName: Bean的名字</span></span><br><span class="line"><span class="comment">mbd: Spring容器中维护了一个BeanDefinitionMap用于注册所有需要实例化的类的注册信息，其中存放的BeanDefinition维护了很多这个类的实例化相关的信息信息。而RootBeanDefinition是BeanDefinition的一个子类。</span></span><br><span class="line"><span class="comment">args: 创建实例时需要的参数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line"><span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">...</span><br><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();<span class="comment">//通过反射实例化Bean</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);<span class="comment">//调用BeanProcessorBean后置处理器</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<span class="comment">//实例化后放入三级缓存区， 即SingletonFactory</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);<span class="comment">//填充Bean的字段，当涉及到循环依赖时</span></span><br><span class="line">    </span><br><span class="line">    ... <span class="comment">//循环依赖校验，这里主要用于处理发生了动态代理的情况，即对Bean进行了增强，导致最终放到二级缓存中的Bean不是原来的Bean，而是一个Proxy代理对象的情况</span></span><br><span class="line">    </span><br><span class="line">    registerDisposableBeanIfNecessary(beanName, bean, mbd);<span class="comment">//添加销毁方法，在bean的生命周期走到尽头---销毁阶段时，会调用它的销毁方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这一切结束之后，Bean会被放入singleObjects 单例池中。</p><p>doCreateBean方法实际上包括于几乎是一个Bean的生命周期的全流程，这里有一个关于Bean生命周期的图：</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://s2.loli.net/2024/10/03/ONMm23ruztcIQkB.png" alt="Spring构建bean时的方法调用"></p><p>它实际上还包含了Aware接口，后处理器等一系列使Spring更灵活的接口的生效时机，但这不是本文所关注的。</p><h1>:o: 写在最后</h1><p>思考一个问题：</p><p>本篇的依赖注入的方法是通过setter注入，如果是构造器注入，还能跳出依赖循环吗？如果它们的实例类型scope都设置为prototype(不使用单例而是每次getBean都重新实例化一个)、如果是自己依赖自己的场景呢？</p><blockquote><p>见参考中的第一篇文章:<a href="#section1">参考文章</a></p></blockquote><p><strong>本篇笔记为本人学习Spring时关于Spring循环依赖的一部分思考和总结，可能存在一些错误，希望指正。</strong></p><p>————————————</p><blockquote><p>参考：<a id="section1"></a></p><p><a href="https://springdoc.cn/revisiting-spring-s-circular-dependencies/"><strong>再谈谈 Spring 中的循环依赖 - spring 中文网 (springdoc.cn</strong>)</a></p><p><a href="https://cloud.tencent.com/developer/article/1497692">一文告诉你Spring是如何利用&quot;三级缓存&quot;巧妙解决Bean的循环依赖问题的 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>想要实现的功能清单</title>
      <link href="/2024/10/02/%E6%83%B3%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E6%B8%85%E5%8D%95/"/>
      <url>/2024/10/02/%E6%83%B3%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<ul><li>一个用于我自己编写前端动画的 “<strong>小巧思</strong>” Page</li><li>一个留言墙，并将留言内容展示在首页顶部</li></ul><p>111</p>    <div id="aplayer-mhhekJPy" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="000PeZCQ1i4XVs" data-server="tencent" data-type="artist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#3F51B5"></div>]]></content>
      
      
      
        <tags>
            
            <tag> 小目标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享一个图片处理网站</title>
      <link href="/2024/09/30/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E7%BD%91%E7%AB%99/"/>
      <url>/2024/09/30/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<p>由于搭设了博客，不希望自己的网站速度太慢，最近做了很多事来加速网站访问，其中一件事就是对网页图片进行处理。</p><p>最开始我使用的是GitHub仓库作为图床，虽然使用<strong>vercel</strong>进行加速，访问速度还是很感人，后来换了<strong>smms</strong>图床，个人实测，访问效果确实有明显改善，但上传速度缺少比不上Github。关于设置图床，网上教程太多了，我自己也是照着教程完成的，就不照本宣科的做搬运了。</p><p>还有一个加速图片加载的方法就是压缩图片，实际上网页访问时很多图片实际上不需要多么清晰，因为它往往不会占据整个页面，即使有一定画质压缩，也完全可以接受，在将较大的图片上传图床之前，先将图片压缩，不仅能加速访问，还能减少图床内存占用。</p><p>所以这里推荐一个非常好用的网站：<a href="https://www.onlineimagetool.com/zh/"><strong>(onlineimagetool.com)</strong></a>，在上传图片进行压缩时，你还可以查看压缩前后的对比，非常好用。网页的效果如下图，挺精美的。</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://s2.loli.net/2024/09/30/s3m4xTKdw8ZLvkV.jpg" alt="网页效果"></p><p>另外再推荐一个更全面的图片处理网站：<a href="https://imagestool.com/zh_CN/"><strong>无需上传文件也可在线处理图片 (imagestool.com)</strong></a>，这个网站非常好的一点是可以上传文件夹进行批量压缩，然后下载压缩包，文件结构依然保留，不过国内无法访问，需要科学上网。</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora+PicGo实现文章图片上传到图床</title>
      <link href="/2024/09/27/Typora-PicGo%E5%AE%9E%E7%8E%B0%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0%E5%9B%BE%E5%BA%8A/"/>
      <url>/2024/09/27/Typora-PicGo%E5%AE%9E%E7%8E%B0%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="Typora-PicGo自动上传到GitHub图床">Typora+PicGo自动上传到GitHub图床</h2><h3 id="1-创建GitHub仓库作为图库">1. 创建GitHub仓库作为图库</h3><p>首先在GitHub新建一个仓库，<a href="http://xn--README-9o7ir7cveu24a4obg6ao8fb4p641abobsx9d5f4auh9k.md">可以在创建仓库时勾选上添加README.md</a></p><p>将以这个仓库作为图床。</p><p>本博客选用CloudFlare CDN堆GitHub图床进行加速。</p><h3 id="2-下载PicGo并进行图床设置">2. 下载PicGo并进行图床设置</h3><p>PicGo是用来将图片上传到图床中的工具，它有支持很多图床，而且还有很多插件，通过插件，你可以选择用B站、Gitee等作为图床，或许就无需进行CDN访问加速也能在国内获得不错的访问加速</p><p>PicGo插件：<a href="https://github.com/PicGo/Awesome-PicGo">github.com/PicGo/Awesome-PicGo</a> （在PicGo客户端也能访问到）</p><p><strong>PicGo的下载网址：</strong><a href="https://github.com/Molunerfinn/picgo/releases">Releases · Molunerfinn/PicGo (github.com)</a></p><p>选择一个稳定版本进行安装即可</p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev/imgs/post_Imags/202409271801423.png" alt="image-20240927145055085" style="zoom:50%;"><p>启动PicGo，在其中进行图床设置。其中Token是你GitHub的个人令牌，如果你没有，在个人GitHub主页点击头像–》Settings(设置)</p><p>下滑找到 Developer seetings(开发者设置)，点击Generate new token(生成新令牌)，勾选下图所示的repo仓库权限，下滑到最下面Generate即可，然后将Token复制到上图的设定Token位置</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev/imgs/post_Imags/202409271801704.png" alt="image-20240927145537275"></p><p>你可以为Token设置一个过期失效，然后在Token失效后自己在PicGo中手动更新Token即可</p><p>一会还需要设置域名方便访问，这在第3部分中<a href="#section1">图床域名访问</a></p><p><a id="section1"></a></p><h3 id="3-图床CDN加速">3. 图床CDN加速</h3><h4 id="3-1-使用jsDelivr加速">3.1 使用jsDelivr加速</h4><p>jsDelivr是免费且开源的内容分发网络，你可以通过它加速和托管前端资源</p><p>jsdelivr的用法非常简单,你只需要在自定义域名中按照如下规则添加即可：</p><p><a href="https://cdn.jsdelivr.net/gh/GitHub%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BB%93%E5%BA%93%E5%90%8D">https://cdn.jsdelivr.net/gh/GitHub用户名/仓库名</a></p><blockquote><p><a href="https://cdn.jsdelivr.net">https://cdn.jsdelivr.net</a> 固定的</p><p>gh表示来源为 GitHub</p><p>后面跟上你的用户名加仓库名即可</p></blockquote><h4 id="3-2-使用CloudFlare">3.2 使用CloudFlare</h4><p><a href="https://www.cloudflare.com/">CloudFlare官网</a></p><p>没有注册的可以注册一下，除了图床访问加速，我们也可以通过它对博客网站进行CDN加速</p><p>在主页找到Pages，点击创建。</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev/imgs/post_Imags/202409271800722.png" alt="image-20240927143031302"></p><p>在创建应用程序中选择连接到Git，并和前面在GitHub中新建的仓库关联，之后全部默认即可</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev/imgs/post_Imags/202409271800799.png" alt="image-20240927143124828"></p><p>部署完成后你就可以在Pages页中看到看到这个仓库的链接，你可以通过这个域名+你的资源路径访问到GitHub仓库中的资源</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev/imgs/post_Imags/202409271802744.png" alt="image-20240927144327697"></p><p>将这个域名复制到PicGo图床设置的自定义域名中，就可以通过网络获取到仓库中的图片了</p><h3 id="4-Typora自动上传">4. Typora自动上传</h3><p>最后一步同时也是注入灵魂的一步，在Typora中配置本地图片自动上传并更新URL，这样就可以在本地编写博客时，直接将图片上传到图床中，博客写完后，直接提交到博客仓库即可，无需手动修改图片链接。</p><p>在Typora中点击文件–》偏好设置</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev/imgs/post_Imags/202409271758308.png" alt="Snipaste_2024-09-27_17-12-03"></p><p>配置完成，现在Typora可以将本地和网络上的图片自动上传到图床了。</p><p>——————————————————</p><blockquote><p>参考：</p><p><a href="https://www.bilibili.com/video/BV13K4y197j7/?spm_id_from=333.880.my_history.page.click&amp;vd_source=3b2548ca76d1728cf98fff60e44d3e0a">Typora+B站，无敌的高速图床，且高度自定义图片参数，只需要两步_哔哩哔哩_bilibili</a></p><p>[手把手教你 Typora + PicGo 配置图床，提高写作效率！ - 知乎 (<a href="http://zhihu.com">zhihu.com</a>)](<a href="https://zhuanlan.zhihu.com/p/469339158#:~:text=%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0">https://zhuanlan.zhihu.com/p/469339158#:~:text=手把手教你</a> Typo)</p><p>[使用 jsDelivr CDN 对 Github 图床进行加速，带给你如丝滑般的图片体验！ - 知乎 (<a href="http://zhihu.com">zhihu.com</a>)](<a href="https://zhuanlan.zhihu.com/p/138582151#:~:text=%E5%AD%A6%E4%B9%A0">https://zhuanlan.zhihu.com/p/138582151#:~:text=学习</a> jsDeliv#:~:text=学习 jsDeliv)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图片处理</title>
      <link href="/2024/09/27/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/"/>
      <url>/2024/09/27/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev/imgs/post_Imags/202409271651201.jpg" alt="e84e3c27ea4547138b08f01e1604953d~tplv-p14lwwcsbr-7.jfif"></p><p><img src= "/img/friend_404.gif" data-lazy-src="https://pic-bed1-9nl.pages.dev//imgs/post_Imags/202409271703114.jpg" alt="报纸墙 长卷发 大波浪美女 4K动漫壁纸_彼岸图网"></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下安装和使用brew</title>
      <link href="/2024/09/25/Linux%E4%B8%8B%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8brew/"/>
      <url>/2024/09/25/Linux%E4%B8%8B%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8brew/</url>
      
        <content type="html"><![CDATA[<h2 id="下载HomeBrew和使用">下载HomeBrew和使用</h2><p>Brew是一个非常流行的开源包管理器，可以理解为一个命令行版本的应用商店。它是相对安全的，如果你知道自己正在下载什么。起码目前 Homebrew 上不存在恶意包，关于它的介绍，可以看：<a href="https://zhuanlan.zhihu.com/p/30704752">Homebrew 使用详解 - 知乎 (zhihu.com)</a></p><p>本文主要用于使用CentOS Linux系统的同学在一部全新的Linux虚拟机上安装Brew，同时也方便本人回顾</p><h3 id="1-安装必要的基础软件">1 安装必要的基础软件</h3><p>本文安装的是 Homebrew 3.0.9 , 官方文档中描述存在如下依赖:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* GCC 4.7.0 or newer</span><br><span class="line">* Linux 2.6.32 or newer</span><br><span class="line">* Glibc 2.13 or newer</span><br><span class="line">* 64-bit x86_64 CPU</span><br></pre></td></tr></table></figure><p>可以跳过 GCC 的检查，之后使用 Homebrew 进行安装。</p><ul><li>检查内核版本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uname -a </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出</span></span><br><span class="line">Linux myhost 3.10.0-957.21.3.el7.x86_64 #1 SMP Tue Jun 18 16:35:19 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux </span><br></pre></td></tr></table></figure><ul><li>检查 Glibc 版本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldd --version </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出</span></span><br><span class="line">ldd (GNU libc) 2.17 Copyright (C) 2012 Free Software Foundation, Inc. This is free software; see the source for copying conditions.  There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure><ul><li>安装基础软件</li></ul><p><em><strong>Development tools</strong></em> 是一个可以给开发编译运维的配置基本初始环境的工具。它包含一系列组合包，可以在初始化脚本配置的时候更方便、快捷、高效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall -y ‘Development Tools’</span><br><span class="line">yum install -y curl file git </span><br></pre></td></tr></table></figure><blockquote><p>当运行yum groupinstall -y ‘Development Tools’时可能会提示无该安装包，这可能是是由于使用的yum源缺乏该安装包导致的</p><p>解决方法是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">//安装epel源</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="built_in">sudo</span> yum install epel-release</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">//更新</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">yum update</span></span><br></pre></td></tr></table></figure><p>🔔：yum源好像已经无法使用，可以更新yum源 <a href="#section2">无法使用yum指令怎么办</a></p></blockquote><h3 id="2-升级-git-和-curl">2 升级 git 和 curl</h3><p>HomeBrew的安装需要使用到git和支持https2的curl版本，由于CentOS默认版本过低，需要更新git和curl的版本</p><ul><li>升级 git 版本，不低于 2.7.0</li></ul><p>🔔 🔔 🔔 🔔</p><p>:exclamation: <strong>原帖这里的更新方法已经失效</strong></p><p>这里使用的是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum install -y https://repo.ius.io/ius-release-el7.rpm</span><br><span class="line">yum install -y epel-release </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">re-install git:</span></span><br><span class="line">yum erase -y git*</span><br><span class="line">yum install -y git-core</span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://blog.csdn.net/qq_26545503/article/details/125617944">linux 升级git_linux升级git版本-CSDN博客</a></p></blockquote><p>查看版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git --version </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出</span></span><br><span class="line">git version 2.36.6</span><br></pre></td></tr></table></figure><ul><li>升级 curl 版本，不低于 7.41.0</li></ul><p>默认版本的curl7.29不支持http2</p><p>🔔 🔔 🔔 🔔</p><p>报错为：<code>无法打开 http://www.city-fan.org/ftp/contrib/yum-repo/</code></p><p>可以试试科学上网</p><p><strong>这里的方法是：</strong></p><blockquote><p>一、添加city-fan.org的源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">vim /etc/yum.repos.d/city-fan.org.repo  <span class="comment"># 编辑文件添加如下</span></span></span><br></pre></td></tr></table></figure><p>二、将以下内容复制过去</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[city-fan.org]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">name=city-fan.org repository <span class="keyword">for</span> Red Hat Enterprise Linux (and clones) <span class="variable">$releasever</span> (<span class="variable">$basearch</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="comment">#baseurl=http://mirror.city-fan.org/ftp/contrib/yum-repo/rhel$releasever/$basearch</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">mirrorlist=http://mirror.city-fan.org/ftp/contrib/yum-repo/mirrorlist-rhel<span class="variable">$releasever</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">enabled=1</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">gpgcheck=0</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-city-fan.org</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[city-fan.org-debuginfo]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">name=city-fan.org debuginfo repository <span class="keyword">for</span> Red Hat Enterprise Linux (and clones) <span class="variable">$releasever</span> (<span class="variable">$basearch</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="comment">#baseurl=http://www.city-fan.org/ftp/contrib-debug/rhel$releasever/$basearch</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">mirrorlist=http://www.city-fan.org/ftp/contrib-debug/mirrorlist-rhel<span class="variable">$releasever</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">enabled=1</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">gpgcheck=0</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-city-fan.org</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[city-fan.org-source]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">name=city-fan.org <span class="built_in">source</span> repository <span class="keyword">for</span> Red Hat Enterprise Linux (and clones) <span class="variable">$releasever</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="comment">#baseurl=http://mirror.city-fan.org/ftp/contrib/yum-repo/rhel$releasever/source</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">mirrorlist=http://mirror.city-fan.org/ftp/contrib/yum-repo/source-mirrorlist-rhel<span class="variable">$releasever</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">enabled=1</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">gpgcheck=0</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-city-fan.org</span></span><br></pre></td></tr></table></figure><p>三、更新curl</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">yum update curl</span></span><br></pre></td></tr></table></figure><p>查看版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">curl --version</span> </span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="comment">#输出</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">curl 8.2.1</span> </span><br></pre></td></tr></table></figure><p>————————————————</p><p>原文链接：<a href="https://www.cnblogs.com/zinging/p/17934351.html">centos7 升级curl-8.2.1 支持http2 （yum update） - 诗里刻画的影子 - 博客园 (cnblogs.com)</a></p><p><a href="https://ec.haxx.se/install/linux.html">Linux的curl相关文档  -  Linux - everything curl (haxx.se)</a></p></blockquote><h3 id="3-安装-Homebrew">3. 安装 Homebrew</h3><ul><li>切换到非 root 用户</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su feng </span><br></pre></td></tr></table></figure><blockquote><p>在此之前，请确认你的非root用户具有使用sudo命令的权限，并为该用户配置sudo(super user do)认证</p><p>如果想要让用户具有超级用户权限请点击：<a href="#section1">跳转到更改用户权限</a></p></blockquote><ul><li>安装 Homebrew</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; </span><br></pre></td></tr></table></figure><blockquote><p>以上下载是github的链接，国内下载速度比较慢，可以用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span><br></pre></td></tr></table></figure><p>若采用此方法下载，有可能还需要安装zsh（如已经安装则跳过此步骤）</p><p>centos使用下面命令安装zsh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update</span><br><span class="line">sudo yum install zsh</span><br></pre></td></tr></table></figure><p>如果是debian或者ubuntu，执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install zsh</span><br></pre></td></tr></table></figure></blockquote><p>(实测通过GitHub下载速度也不慢)</p><blockquote><p>下载过程中可能会出现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">error: RPC 失败。curl 92 HTTP/2 stream 5 was not closed cleanly: CANCEL (err 8)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">error: 预期仍然需要 2109 个字节的正文</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">fetch-pack: unexpected disconnect <span class="keyword">while</span> reading sideband packet</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">fatal: 过早的文件结束符（EOF）</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">fatal: fetch-pack：无效的 index-pack 输出</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">Failed during: /bin/git fetch --force origin</span></span><br></pre></td></tr></table></figure><p>这是由于网络状况差导致的</p><p>请尝试更换网络或等待网络状态正常时继续进行</p></blockquote><ul><li>添加 brew 命令到 PATH</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test -d ~/.linuxbrew &amp;&amp; eval $(~/.linuxbrew/bin/brew shellenv)</span><br><span class="line">test -d /home/linuxbrew/.linuxbrew &amp;&amp; eval $(/home/linuxbrew/.linuxbrew/bin/brew shellenv)</span><br><span class="line">test -r ~/.bash_profile &amp;&amp; echo &quot;eval \$($(brew --prefix)/bin/brew shellenv)&quot; &gt;&gt;~/.bash_profile</span><br><span class="line">echo &quot;eval \$($(brew --prefix)/bin/brew shellenv)&quot; &gt;&gt;~/.profile</span><br></pre></td></tr></table></figure><p>直接将 <code>.linuxbrew/bin</code> 添加到 PATH 会导致安装新工具时，make 报错。</p><ul><li>查看版本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew  --version</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出</span></span><br><span class="line">Homebrew 4.3.24</span><br><span class="line">Homebrew/homebrew-core (git revision 1ce004f2f0b; last commit 2021-03-28)</span><br></pre></td></tr></table></figure><ul><li>[可选]添加 brew 到 Zsh</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test -r ~/.zshrc &amp;&amp; echo &quot;eval \$($(brew --prefix)/bin/brew shellenv)&quot; &gt;&gt;~/.zshrc</span><br></pre></td></tr></table></figure><h3 id="4-使用">4. 使用</h3><ul><li>安装 GCC</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">brew install gcc</span><br><span class="line"></span><br><span class="line">==&gt; Downloading https://linuxbrew.bintray.com/bottles/isl-0.23.x86_64_linux.bottle.tar.gz</span><br><span class="line">==&gt; Downloading from https://akamai.bintray.com/46/46537a01a0cc82ea18528293b6bac03be7ab14b2fc3a7a28051f1b26e24f6c57?__gda__=exp=1616978202~hmac=b7727c9ae79b54bebc199a095c01e70251446ed4012bfb5900dd877e06229fd1&amp;response-content-disposition=attachment%3Bfilename%3D%22isl-0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">####################################################################### 100.0%</span></span></span><br><span class="line">==&gt; Downloading https://linuxbrew.bintray.com/bottles/gcc-10.2.0_4.x86_64_linux.bottle.tar.gz</span><br><span class="line">==&gt; Downloading from https://akamai.bintray.com/e6/e62efea399fd03d854ff871210b941e5c3277d821e9148badceeda883f53f016?__gda__=exp=1616978204~hmac=a7e19e02629bc1c462635349fe3c01039f581e2014153c704f72e54bc2d93c35&amp;response-content-disposition=attachment%3Bfilename%3D%22gcc-1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################                                                         24.9%</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">####################################################################### 100.0%</span></span></span><br><span class="line">==&gt; Installing dependencies for gcc: isl</span><br><span class="line">==&gt; Installing gcc dependency: isl</span><br><span class="line">==&gt; Pouring isl-0.23.x86_64_linux.bottle.tar.gz</span><br><span class="line">🍺  /home/linuxbrew/.linuxbrew/Cellar/isl/0.23: 73 files, 6.6MB</span><br><span class="line">==&gt; Installing gcc</span><br><span class="line">==&gt; Pouring gcc-10.2.0_4.x86_64_linux.bottle.tar.gz</span><br><span class="line">Warning: The post-install step did not complete successfully</span><br><span class="line">You can try again using:</span><br><span class="line">  brew postinstall gcc</span><br><span class="line">==&gt; Summary</span><br><span class="line">🍺  /home/linuxbrew/.linuxbrew/Cellar/gcc/10.2.0_4: 1,481 files, 264.3MB</span><br><span class="line">==&gt; No outdated dependents to upgrade!</span><br><span class="line">==&gt; Checking for dependents of upgraded formulae...</span><br><span class="line">==&gt; Reinstalling 1 broken dependent from source:</span><br><span class="line">gcc</span><br></pre></td></tr></table></figure><ul><li>安装 Kubectl</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">brew install kubectl</span><br><span class="line"></span><br><span class="line">==&gt; Downloading https://linuxbrew.bintray.com/bottles/kubernetes-cli-1.20.4_1.x86_64_linux.bottle.tar.gz</span><br><span class="line">==&gt; Downloading from https://akamai.bintray.com/c5/c5dd394d0bd150aff18ded31f29e52ece6dcbd064ebe46e7f746891822a12eff?__gda__=exp=1616978407~hmac=13c24ddb7a7e90118b1aa8184d2c4688f719a945c4f0d033352a7cae9c845887&amp;response-content-disposition=attachment%3Bfilename%3D%22kuber</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">####################################################################### 100.0%</span></span></span><br><span class="line">==&gt; Pouring kubernetes-cli-1.20.4_1.x86_64_linux.bottle.tar.gz</span><br><span class="line">==&gt; Caveats</span><br><span class="line">Bash completion has been installed to:</span><br><span class="line">  /home/linuxbrew/.linuxbrew/etc/bash_completion.d</span><br><span class="line">==&gt; Summary</span><br><span class="line">🍺  /home/linuxbrew/.linuxbrew/Cellar/kubernetes-cli/1.20.4_1: 246 files, 40.9MB</span><br></pre></td></tr></table></figure><ul><li>安装 Kind</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">brew install kind</span><br><span class="line"></span><br><span class="line">==&gt; Downloading https://linuxbrew.bintray.com/bottles/kind-0.10.0.x86_64_linux.bottle.tar.gz</span><br><span class="line">==&gt; Downloading from https://akamai.bintray.com/7a/7a5595da7f271219a53cbd95a5b729c581fb3e4f8ece6d449074cbe33f10d627?__gda__=exp=1616978455~hmac=754a3789f01e3c27ebdfa1b65e51392eaeacf61f878a9d607b78d342f52c5dfa&amp;response-content-disposition=attachment%3Bfilename%3D%22kind-</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">####################################################################### 100.0%</span></span></span><br><span class="line">==&gt; Pouring kind-0.10.0.x86_64_linux.bottle.tar.gz</span><br><span class="line">==&gt; Caveats</span><br><span class="line">Bash completion has been installed to:</span><br><span class="line">  /home/linuxbrew/.linuxbrew/etc/bash_completion.d</span><br><span class="line">==&gt; Summary</span><br><span class="line">🍺  /home/linuxbrew/.linuxbrew/Cellar/kind/0.10.0: 8 files, 9.4MB</span><br></pre></td></tr></table></figure><hr><p>————————————————</p><p>原文链接：<a href="https://www.chenshaowen.com/blog/install-homebrew-in-centos-7.html">CentOS 7 下安装并配置 Homebrew – 陈少文的网站 (chenshaowen.com)</a></p><h2 id="使用brew安装nodejs">使用brew安装nodejs</h2><p>当我使用homebrew安装nodejs后，它要求我进行配置。提示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">==&gt; Installing node@20</span><br><span class="line">==&gt; Pouring node@20--20.17.0.x86_64_linux.bottle.tar.gz</span><br><span class="line">==&gt; Caveats</span><br><span class="line">node@20 is keg-only, which means it was not symlinked into /home/linuxbrew/.linuxbrew,</span><br><span class="line">because this is an alternate version of another formula.</span><br><span class="line"></span><br><span class="line">If you need to have node@20 first in your PATH, run:</span><br><span class="line">  echo &#x27;export PATH=&quot;/home/linuxbrew/.linuxbrew/opt/node@20/bin:$PATH&quot;&#x27; &gt;&gt; /home/feng/.bash_profile</span><br><span class="line"></span><br><span class="line">For compilers to find node@20 you may need to set:</span><br><span class="line">  export LDFLAGS=&quot;-L/home/linuxbrew/.linuxbrew/opt/node@20/lib&quot;</span><br><span class="line">  export CPPFLAGS=&quot;-I/home/linuxbrew/.linuxbrew/opt/node@20/include&quot;</span><br><span class="line">==&gt; Summary</span><br><span class="line">🍺  /home/linuxbrew/.linuxbrew/Cellar/node@20/20.17.0: 2,068 files, 66.6MB</span><br><span class="line">==&gt; Running `brew cleanup node@20`...</span><br><span class="line">Disable this behaviour by setting HOMEBREW_NO_INSTALL_CLEANUP.</span><br><span class="line">Hide these hints with HOMEBREW_NO_ENV_HINTS (see `man brew`).</span><br><span class="line">==&gt; Caveats</span><br><span class="line">==&gt; node@20</span><br><span class="line">node@20 is keg-only, which means it was not symlinked into /home/linuxbrew/.linuxbrew,</span><br><span class="line">because this is an alternate version of another formula.</span><br><span class="line"></span><br><span class="line">If you need to have node@20 first in your PATH, run:</span><br><span class="line">  echo &#x27;export PATH=&quot;/home/linuxbrew/.linuxbrew/opt/node@20/bin:$PATH&quot;&#x27; &gt;&gt; /home/feng/.bash_profile</span><br><span class="line"></span><br><span class="line">For compilers to find node@20 you may need to set:</span><br><span class="line">  export LDFLAGS=&quot;-L/home/linuxbrew/.linuxbrew/opt/node@20/lib&quot;</span><br><span class="line">  export CPPFLAGS=&quot;-I/home/linuxbrew/.linuxbrew/opt/node@20/include&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>其中的有用信息是:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">node@20 is keg-only, which means it was not symlinked into /home/linuxbrew/.linuxbrew,</span><br><span class="line">because this is an alternate version of another formula.</span><br><span class="line"></span><br><span class="line">If you need to have node@20 first in your PATH, run:</span><br><span class="line">  echo &#x27;export PATH=&quot;/home/linuxbrew/.linuxbrew/opt/node@20/bin:$PATH&quot;&#x27; &gt;&gt; /home/feng/.bash_profile</span><br><span class="line"></span><br><span class="line">For compilers to find node@20 you may need to set:</span><br><span class="line">  export LDFLAGS=&quot;-L/home/linuxbrew/.linuxbrew/opt/node@20/lib&quot;</span><br><span class="line">  export CPPFLAGS=&quot;-I/home/linuxbrew/.linuxbrew/opt/node@20/include&quot;</span><br></pre></td></tr></table></figure><p>按照提示所说，运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里由于用户名不同文件位置可能也有所不同，请参考Linux的提示</span></span><br><span class="line">echo &#x27;export PATH=&quot;/home/linuxbrew/.linuxbrew/opt/node@20/bin:$PATH&quot;&#x27; &gt;&gt; /home/feng/.bash_profile</span><br></pre></td></tr></table></figure><p>将以下内容添加到  ~/.bashrc中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bashrc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将以下内容添加最后面</span></span><br><span class="line">export LDFLAGS=&quot;-L/home/linuxbrew/.linuxbrew/opt/node@20/lib&quot;</span><br><span class="line">export CPPFLAGS=&quot;-I/home/linuxbrew/.linuxbrew/opt/node@20/include&quot;</span><br></pre></td></tr></table></figure><p>配置完成后，运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出</span></span><br><span class="line">bash: node: command not found...</span><br></pre></td></tr></table></figure><p><strong>发现仍然不能使用node</strong></p><p><em><strong>解决方法：</strong></em></p><p><strong>检查 Node.js 是否安装</strong>： 运行以下命令来确认 Node.js 是否在 Homebrew 中安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew list | grep node</span><br></pre></td></tr></table></figure><p>如果没有找到 Node.js，尝试重新安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node@20</span><br></pre></td></tr></table></figure><p><strong>添加 Node.js 到 <code>PATH</code></strong>： 如果 Node.js 已安装，但仍然无法找到，可能是 <code>PATH</code> 没有正确设置。你可以将 Node.js 的安装路径添加到你的 <code>PATH</code> 中。在 <code>~/.bashrc</code> 或 <code>~/.zshrc</code> 文件中添加以下行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bashrc <span class="comment">#或者vi ~/.zshrc</span></span><br><span class="line"><span class="comment">#将以下内容复制到文件中</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/home/linuxbrew/.linuxbrew/opt/node@20/bin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure><p>然后保存文件并运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>或者如果你使用的是 Zsh：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><p><strong>验证安装</strong>： 再次检查 Node.js 是否可以正常使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">v20.17.0</span><br></pre></td></tr></table></figure><p>安装成功</p><ul><li>如果你需要使用最新版的npm，请运行：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm@latest</span><br></pre></td></tr></table></figure><ul><li><code>npm</code>默认的官网源可能会比较慢，如果想要后续的下载速度快一些，可以通过下面的方式将源设置为淘宝源或阿里源。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry <span class="comment"># 查看源</span></span><br><span class="line"><span class="comment">#哪个国内镜像源都可以</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com <span class="comment"># 修改为淘宝源</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://npm.aliyun.com <span class="comment">#修改为阿里源</span></span><br></pre></td></tr></table></figure><p><strong>文章中的源都具有时效性</strong></p><p>如果源不可用，可以自行查找最新的镜像源并更新</p><hr><p><strong>以下内容不一定需要</strong></p><p><a id="section1"></a></p><h2 id="更改普通用户权限">更改普通用户权限</h2><p>1.切换到root用户下</p><p>su -</p><p>2.添加sudo文件的写权限,命令是:<br>chmod u+w /etc/sudoers</p><p>3.编辑sudoers文件<br>vi /etc/sudoers<br>找到这行 root ALL=(ALL) ALL,在他下面添加xxx ALL=(ALL) ALL (这里的xxx是你的用户名)</p><p>ps:这里说下你可以sudoers添加下面四行中任意一条</p><pre><code>youuser            ALL=(ALL)                ALL  %youuser           ALL=(ALL)                ALL  youuser            ALL=(ALL)                NOPASSWD: ALL  %youuser           ALL=(ALL)                NOPASSWD: ALL  </code></pre><p>第一行:允许用户youuser执行sudo命令(需要输入密码).<br>第二行:允许用户组youuser里面的用户执行sudo命令(需要输入密码).<br>第三行:允许用户youuser执行sudo命令,并且在执行的时候不输入密码.<br>第四行:允许用户组youuser里面的用户执行sudo命令,并且在执行的时候不输入密码.</p><p>4.撤销sudoers文件写权限,命令:<br>chmod u-w /etc/sudoers</p><p>这样普通用户就可以使用sudo了.<br>补充：</p><p>注意，在Ubuntu系统下，Unix操作系统并没有为root创建密码，需要使用sudo passwd root来为root用户配置密码，之后才可以登入。</p><h2 id="无法使用yum指令">无法使用yum指令</h2><p>CentOS报错：Could not retrieve mirrorlist <a href="http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=os&amp;i">http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=os&amp;i</a></p><p>最终解决方法：<strong>更新yum源</strong></p><p>具体参考这篇博客：<a href="https://blog.csdn.net/gnwu1111/article/details/140172717?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-140172717-blog-103771510.235">yum指令报错</a></p><p>简单存个档，以防网页丢失：</p><blockquote><p>1、检查网络配置是否正常</p><p>在linux下ping一下看看是不是网络链接正常。出现这种原因就是一般网络没链接好。那修改一下dns，找到/etc/sysconfig/network-scripts/ifcfg-ens33<br>注意一下，ifcfg-ens33后面的数字是随机产生的</p><p>将onboot改为yes，重新启动网络，service network restart，然后ping www.baidu.com如果通了的话，就证明链接成功。这样就可以正常yum update了</p></blockquote><blockquote><p>2、检查有没有配置/etc/resolv.conf</p><p>解决方法：</p><p>vi /etc/resolv.conf</p><p>:wq保存退出即可，之后再执行yum操作，成功！</p></blockquote><p><a id="section2"></a></p><p>3、如果还不行 <strong>更新yum源</strong><br>　　使用阿里源：</p><p>​1.备份当前的yum源</p><p><code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></p><p>​2.下载新的CentOS-Base.repo 到/etc/yum.repos.d/</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　CentOS 5</span><br><span class="line"> </span><br><span class="line">　　　　wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-5.repo</span><br><span class="line"> </span><br><span class="line">　　　　或者</span><br><span class="line"> </span><br><span class="line">　　　　curl -o /etc/yum.repos.d/CentOS-Base.repo </span><br><span class="line">     </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　　　CentOS 6</span><br><span class="line"> </span><br><span class="line">　　　　wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo</span><br><span class="line"> </span><br><span class="line">　　　　或者</span><br><span class="line"> </span><br><span class="line">　　　　curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　　　CentOS 7</span><br><span class="line"> </span><br><span class="line">　　　　wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"> </span><br><span class="line">　　　　或者</span><br><span class="line"> </span><br><span class="line">　　　　curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure><ol start="3"><li><p>清空并生成缓存</p><p>​   yum clean all</p></li></ol><p>​  yum makecache<br>　　🔔:　yum 会把下载的软件包和header存储在cache中(默认路径/var/cache/yum/)，而不自动删除。如果觉得占用磁盘空间，可以使用yum clean指令进行清除，更精确 的用法是yum clean headers清除header，yum clean packages清除下载的rpm包，yum clean all全部清除。</p><p>使用网易源：</p><p>1.网易<br>　　　2.备份当前的yum源</p><p><code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></p><p>3. 下载对应版本repo文件, 放入/etc/yum.repos.d/</p><p>🔔和前面阿里云的是一样的，只需要更改网址即可</p><blockquote><p><a href="http://mirrors.163.com/.help/CentOS5-Base-163.repo">http://mirrors.163.com/.help/CentOS5-Base-163.repo</a>CentOS5</p><p><a href="http://mirrors.163.com/.help/CentOS6-Base-163.repo">http://mirrors.163.com/.help/CentOS6-Base-163.repo</a>CentOS6</p><p><a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo">http://mirrors.163.com/.help/CentOS7-Base-163.repo</a>CentOS7</p></blockquote><p>4.运行以下命令生成缓存</p><p>​  yum clean all</p><p>​  yum makecache<br>————————————————</p><p>原文链接：<a href="https://blog.csdn.net/gnwu1111/article/details/140172717">https://blog.csdn.net/gnwu1111/article/details/140172717</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下的图形化界面</title>
      <link href="/2024/09/24/Linux%E4%B8%8B%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/"/>
      <url>/2024/09/24/Linux%E4%B8%8B%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="如何在CentOS-Linux中使用图形化界面">如何在CentOS Linux中使用图形化界面</h2><p>当自己安装Linux系统时，只能在命令行交互，不够直观</p><p>本处通过图形化界面 X Window System实现图形化界面显示</p><p>进入后命令行出现，首先登陆root用户获取权限才能进行配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su -</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入密码</span></span><br></pre></td></tr></table></figure><ul><li>先查看是否能上网。<br>查看ip地址，看网卡编号。输入代码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show</span><br></pre></td></tr></table></figure><ul><li>查看网卡编号，网卡为ens33。</li></ul><p>​知道网卡编号后，查看网卡状态，输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure><p>​发现网卡关闭（ONBOOT=no），开启网卡，输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifup ens33</span><br></pre></td></tr></table></figure><p>​打开该网卡</p><p>​开启网卡后，检查是否能上网，输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><blockquote><p>按下crtl + c 结束</p></blockquote><ul><li>开始安装图形界面，先安装X Window System<br>输入命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall &quot;X Window System&quot;</span><br></pre></td></tr></table></figure><p>​安装过程有问你选择（y/n）一律</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y</span><br></pre></td></tr></table></figure><p>​显示complete！，安装成功。</p><ul><li>然后开始安装图形界面。<br>输入命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall -y &quot;GNOME&quot;</span><br></pre></td></tr></table></figure><p>​安装图形界面，有问选择（y/n）也是一律</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y</span><br></pre></td></tr></table></figure><p>​直到complete！</p><p>​然后输入进入图形界面指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init 5</span><br></pre></td></tr></table></figure><p>​或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startx</span><br></pre></td></tr></table></figure><p>进入图形界面</p><p>至此，Centos7命令和图形界面安装及下载完成。</p><p>————————————————</p><p>原文链接：<a href="https://blog.csdn.net/weixin_47903763/article/details/109011614">CentOS 7 命令行界面与图形界面安装下载及图文注释（附下载链接）</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2024/09/24/test/"/>
      <url>/2024/09/24/test/</url>
      
        <content type="html"><![CDATA[<p><img src= "/img/friend_404.gif" data-lazy-src="/2024/09/24/test/%E6%9C%88%E5%85%89%E4%B8%8B%E7%9A%84%E5%BE%B7%E7%B4%AF%E6%96%AF%E9%A1%BF.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
